(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{208:function(t,a,v){"use strict";v.r(a);var _=v(28),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("本文主要是对学习"),v("a",{attrs:{href:"https://time.geekbang.org/column/article/147501",target:"_blank",rel:"noopener noreferrer"}},[t._v("极客时间——浏览器的原理与实践"),v("OutboundLink")],1),t._v("的一个总结笔记。")]),t._v(" "),v("h2",{attrs:{id:"http0-9"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http0-9"}},[t._v("#")]),t._v(" http0.9")]),t._v(" "),v("h3",{attrs:{id:"需求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),v("p",[t._v("主要用于学术交流，需求很简单——用来在网络之间传递 "),v("strong",[t._v("HTML 超文本的内容")]),t._v("，所以被称为超文本传输协议")]),t._v(" "),v("h3",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("ul",[v("li",[t._v("只有一个请求行，并没有 HTTP 请求头和请求体")]),t._v(" "),v("li",[t._v("服务器也没有返回头信息，返回数据即可")]),t._v(" "),v("li",[t._v("返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的")])]),t._v(" "),v("h3",{attrs:{id:"发展的限制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发展的限制"}},[t._v("#")]),t._v(" 发展的限制")]),t._v(" "),v("p",[t._v("随着网络的发展，浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件，因此需要支持")]),t._v(" "),v("ul",[v("li",[t._v("支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件")])]),t._v(" "),v("h3",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),v("p",[t._v("没有header，只有简单的html格式的文件")]),t._v(" "),v("h2",{attrs:{id:"http1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[t._v("#")]),t._v(" http1.0")]),t._v(" "),v("h3",{attrs:{id:"需求-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#需求-2"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),v("p",[t._v("要"),v("strong",[t._v("传输不同类型的文件")]),t._v("，因此涉及到类型协商、压缩方式协商（网络上的文件越来越大，需要压缩）、语言协商（全球化）、编码方式协商（不同类型文件的编码方式不一样）等")]),t._v(" "),v("h3",{attrs:{id:"特点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("ul",[v("li",[t._v("支持了不同类型的文件")]),t._v(" "),v("li",[t._v("引入了状态码，")]),t._v(" "),v("li",[t._v("引入了缓存机制")]),t._v(" "),v("li",[t._v("加入了用户代理（userAgent）等用户信息字段，方便统计用户信息")])]),t._v(" "),v("h3",{attrs:{id:"小结-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),v("p",[t._v("引入了header，包括内容协商、状态码、用户代理等")]),t._v(" "),v("h2",{attrs:{id:"http1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" http1.1")]),t._v(" "),v("h3",{attrs:{id:"改进"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#改进"}},[t._v("#")]),t._v(" 改进")]),t._v(" "),v("p",[t._v("基于1.0，做了大量更新，包括")]),t._v(" "),v("h4",{attrs:{id:"引入持久连接（默认）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引入持久连接（默认）"}},[t._v("#")]),t._v(" 引入持久连接（默认）")]),t._v(" "),v("p",[t._v("持久连接在1.0中就存在，但需要请求头加上"),v("code",[t._v("connection:keep-alive")]),t._v("，在http1.1中改为默认持久连接，只要浏览器或者服务器没有明确断开连接（"),v("code",[t._v("connection:close")]),t._v("），那么该 TCP 连接会一直保持。持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体http的请求时长。")]),t._v(" "),v("p",[t._v("目前浏览器对一个域名下允许6个TCP 持久连接。")]),t._v(" "),v("h4",{attrs:{id:"不成熟的管线化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不成熟的管线化"}},[t._v("#")]),t._v(" 不成熟的管线化")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("为解决队头阻塞问题：请求响应是半双工的，也就是下一次请求必须等到返回了才能开始，这样当上个请求没有返回时，可能会形成队头阻塞")])]),t._v(" "),v("li",[v("p",[t._v("管线化是指将在一个长连接中，在响应到达前，可以将多条请求放入队列并依次提交给服务器，在高时延的网络条件下，这样做可以降低网络的环回时间，提高性能；不过虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。")])])]),t._v(" "),v("p",[t._v("因为各种原因，未成功推行")]),t._v(" "),v("h4",{attrs:{id:"提供虚拟主机支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提供虚拟主机支持"}},[t._v("#")]),t._v(" 提供虚拟主机支持")]),t._v(" "),v("p",[t._v("随着发展，一台物理主机（一个ip）上可能有多个虚拟主机，即多个域名域名，因此增加host字段，表明当前域名")]),t._v(" "),v("h4",{attrs:{id:"支持动态内容（分块编码传输）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#支持动态内容（分块编码传输）"}},[t._v("#")]),t._v(" 支持动态内容（分块编码传输）")]),t._v(" "),v("p",[t._v("1.0中，服务器返回数据时，需要在header中设置content-length的大小，这样那浏览器可以通过大小来接收数据；随着发展，很多内容是动态生成，想要准确获取长度，必须开一个足够大的buffer，等内容全部生成完毕再计算，这样内存开销大且耗时，于是HTTP1.1引入了"),v("strong",[t._v("Chunk transfer 机制")]),t._v("。")]),t._v(" "),v("p",[t._v("Chunk transfer 机制中，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上当前数据块的长度和数据，最后使用一个长度为0的空数据块作为发送数据完成的标志。更详细内容参见"),v("a",{attrs:{href:"https://imququ.com/post/transfer-encoding-header-in-http.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 协议中的 Transfer-Encoding"),v("OutboundLink")],1)]),t._v(" "),v("h4",{attrs:{id:"客户端cookie，安全机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#客户端cookie，安全机制"}},[t._v("#")]),t._v(" 客户端cookie，安全机制")]),t._v(" "),v("h3",{attrs:{id:"不足"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不足"}},[t._v("#")]),t._v(" 不足")]),t._v(" "),v("p",[t._v("存在的最大的不足是，"),v("strong",[t._v("对带宽的利用不足")]),t._v("，与以下几个原因有关")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("tcp慢启动")]),t._v("：tcp会解决网络拥塞的问题，在建立刚开始，会采用比较慢的速度发送数据，然后慢慢加快；然而页面中常用的一些关键文件本来就不大，采用tcp慢启动，耗费的时间较长")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("同时开启的多个tcp会竞争带宽")]),t._v("：多条 TCP 连接之间不能协商让哪些关键资源优先下载，当带宽不足时，各个TCP 连接就需要动态减慢接收数据的速度，这样就有可能影响那些关键资源的下载速度了。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("队头阻塞问题")]),t._v("：无论是否持久连接，一个管道同一时刻只能处理一个请求，当前请求没有结束，则后面的请求只能排队等着。")])])]),t._v(" "),t._v(" --\x3e\n"),v("h2",{attrs:{id:"http2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" http2.0")]),t._v(" "),v("h3",{attrs:{id:"分析——多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分析——多路复用"}},[t._v("#")]),t._v(" 分析——多路复用")]),t._v(" "),v("ul",[v("li",[t._v("基于tcp慢启动和多个tcp连接竞争带来的问题，无法改变tcp，就要尽量规避，因此http2.0采用一个域名只使用一个长连接，这样只需要一次慢启动，且避免了多个tcp竞争的问题。")]),t._v(" "),v("li",[t._v("对于队头阻塞问题，是由于后面的资源需要等待前面的资源完成才能去请求，因此http2.0需要实现资源的并行请求。")])]),t._v(" "),v("p",[v("strong",[t._v("目标")]),t._v("：因此http2.0要做的就是"),v("strong",[t._v("采用一个域名只使用一个长连接，且实现资源的并行请求")]),t._v("。")]),t._v(" "),v("p",[v("strong",[t._v("方案")]),t._v("：http2.0解决上述问题的方案就是"),v("strong",[t._v("多路复用")]),t._v("，参考下图：\n"),v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcyy8pjtv8j32410u0k9o.jpg",alt:""}}),t._v("\n每个请求有一个自己的id，比如stream1代表对index.html的请求，stream2是对foo.css的请求，这样浏览器可以随时发送请求给服务器；而服务器收到请求也可根据自己的当前状况，选择返回哪些请求，不依赖顺序可随意发送，浏览器在接收到时，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。")]),t._v(" "),v("h3",{attrs:{id:"实现——二进制帧层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现——二进制帧层"}},[t._v("#")]),t._v(" 实现——二进制帧层")]),t._v(" "),v("p",[t._v("那以上提到的多路复用是如何实现的呢？")]),t._v(" "),v("p",[t._v("引入"),v("strong",[t._v("二进制帧层")]),t._v("。数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器；服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。同样，服务器返回消息时也一样，浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。")]),t._v(" "),v("p",[t._v("多路复用是http2.0最核心的功能，通过二进制帧层实现，通过二进制帧层，还附带了许多其他功能，如下")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("设置优先级")]),t._v("：对关键资源优先响应")]),t._v(" "),v("li",[v("strong",[t._v("服务端推送")]),t._v("：服务器可主动给客户端推送消息。当服务端收到客户端一个html文件的请求时，服务端可知道html需要引用哪些其他资源，此时服务器可不用等客户端请求，一并将其他资源也返回，这样可加快首屏时间。")]),t._v(" "),v("li",[v("strong",[t._v("头部压缩")]),t._v("：提高传输效率\n")])]),t._v(" "),v("h3",{attrs:{id:"限制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[t._v("#")]),t._v(" 限制")]),t._v(" "),v("p",[t._v("http2.0几乎解决了http1.1的不足，但是由于tcp协议的限制，仍然存在"),v("strong",[t._v("数据包级别的队头阻塞")]),t._v(" "),v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/006tNbRwgy1galv24sixpj30x60bgab8.jpg",alt:"tcp丢包状态"}}),t._v("\n如上图，tcp协议中，包必须按发送的顺序接收，当前面的包发生丢包时，就会阻塞后面的包的接收。")]),t._v(" "),v("p",[t._v("http2.0中，多个请求在一个tcp管道中，如果任意一个请求出现丢包，会影响所有其他请求（HTTP1.1中只会影响当前请求），因此当丢包率达到一定值时（测试数据为2%），http2.0的变现比http1.1更差。")]),t._v(" "),v("h3",{attrs:{id:"抛弃针对http1-x的优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#抛弃针对http1-x的优化"}},[t._v("#")]),t._v(" 抛弃针对HTTP1.x的优化")]),t._v(" "),v("p",[t._v("在使用HTTP1.x进行通信时，针对HTTP1.x的不足，开发者采用了许多方案来优化性能，而这方案在HTTP2.0中不再需要，甚至起到相反作用")]),t._v(" "),v("h5",{attrs:{id:"_1、雪碧图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、雪碧图"}},[t._v("#")]),t._v(" 1、雪碧图")]),t._v(" "),v("p",[t._v("HTTP/1.x中，为了减少多个图片请求带来的队头阻塞问题，会采用多个图片拼装为一个图片，而HTTP2.0解决了队头阻塞问题，因此此优化方案不再需要；\n反而会带来需要额外的CSS代码来指明图片位置，增加工作量、增加代码量。")]),t._v(" "),v("h6",{attrs:{id:"_2、域名分片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、域名分片"}},[t._v("#")]),t._v(" 2、域名分片")]),t._v(" "),v("p",[t._v("HTTP/1.x中，一个域名下虽然可以维持多个TCP长连接，但最多也只有6个，因此传输大文件时，为了解决队头阻塞而导致传输时间过长的问题，会采用域名分片的方案——将资源采用CDN的方式分布到多个子域名下，这样同时并发的请求数就为CDN数*6，提高加载速度。")]),t._v(" "),v("p",[t._v("在HTTP2.0中，因为不存在队头阻塞的问题，因此不再需要此方案，否则反而增加了实现的负责度。")]),t._v(" "),v("h3",{attrs:{id:"小结-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结-3"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),v("p",[t._v("http通过多路复用解决了tcp慢启动、多个tcp连接竞争和http1.1队头阻塞的问题，但是http2.0依然基于tcp，tcp协议依然存在"),v("strong",[t._v("数据包级别")]),t._v("的队头阻塞")]),t._v(" "),v("blockquote",[v("p",[t._v("Akamai公司给出了一个demo，用于对比在存在大量请求情况下HTTP/2与HTTP/1.x之间巨大的性能的差异，"),v("a",{attrs:{href:"https://http2.akamai.com/demo",target:"_blank",rel:"noopener noreferrer"}},[t._v("地址"),v("OutboundLink")],1),t._v("，可以体验感受下。")])]),t._v(" "),v("h2",{attrs:{id:"http3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[t._v("#")]),t._v(" http3")]),t._v(" "),v("h3",{attrs:{id:"思路一：改进tcp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路一：改进tcp协议"}},[t._v("#")]),t._v(" 思路一：改进tcp协议")]),t._v(" "),v("p",[t._v("基于tcp协议的机制给http2.0带来的限制，http3.0想要改进应该不再是从http入手，而是从传输层协议tcp协议入手；然而tcp协议经过这么长的历史，")]),t._v(" "),v("ul",[v("li",[t._v("中间设备（路由器、交换机）等都使用了大量的tcp协议且很少更新，")]),t._v(" "),v("li",[t._v("tcp协议都是操作系统内核实现的，操作系统的更新困难且都是滞后于软件的更新的")])]),t._v(" "),v("p",[t._v("以上原因都使得"),v("strong",[t._v("通过改进tcp协议来提升http的效率不太可能")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"思路二：发明一个新协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路二：发明一个新协议"}},[t._v("#")]),t._v(" 思路二：发明一个新协议")]),t._v(" "),v("p",[t._v("与改进tcp协议面临同样的问题，中间设备和操作系统对新协议的支持都不够")]),t._v(" "),v("h3",{attrs:{id:"思路三：包装udp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路三：包装udp协议"}},[t._v("#")]),t._v(" 思路三：包装udp协议")]),t._v(" "),v("p",[t._v("udp协议与tcp协议一样，有着比较长的历史，中间设备和操作系统对两者都有较好的支持；只要让udp协议能够实现tcp协议的功能（包括传输可靠性等），就可以突破以上障碍了。")]),t._v(" "),v("h3",{attrs:{id:"实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),v("p",[t._v("以上提到的对udp的包装，实际上是在udp上加了一层，称作QUIC协议\n"),v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/006tNbRwgy1galv37l44lj30m80ko764.jpg",alt:"http2和http3协议栈"}}),t._v("\n如上图，QUIC集成了")]),t._v(" "),v("ul",[v("li",[t._v("类似tcp的流量控制、可靠传输功能")]),t._v(" "),v("li",[t._v("TLS加密功能")]),t._v(" "),v("li",[t._v("http2.0的多路复用功能，和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图），实现了数据流的单独传输解决了tcp的队头阻塞问题")]),t._v(" "),v("li",[t._v("实现了快速握手，QUIC基于UDP，不需要3次握手，只需要使用 0-RTT 或者 1-RTT 来建立连接\n"),v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/006tNbRwgy1galv3f4e0yj30x60ao3zq.jpg",alt:"QUIC协议的多路复用"}})])]),t._v(" "),v("h3",{attrs:{id:"挑战"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#挑战"}},[t._v("#")]),t._v(" 挑战")]),t._v(" "),v("p",[t._v("http3.0基于思路三实现，但面临许多挑战")]),t._v(" "),v("ul",[v("li",[t._v("浏览器没有对http3.0提供完整的支持")]),t._v(" "),v("li",[t._v("部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因")]),t._v(" "),v("li",[t._v("中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率")])]),t._v(" "),v("h3",{attrs:{id:"小结-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结-4"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),v("p",[t._v("http3.0采用在tcp上加一个QUIC层的方式，绕过了tcp队头阻塞的问题，但由于中间设备和操作系统对udp的优化都远不及tcp，所以http3.0想要用于实际环境，还面临很多挑战。")]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/147501",target:"_blank",rel:"noopener noreferrer"}},[t._v("极客时间——浏览器的原理与实践"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);