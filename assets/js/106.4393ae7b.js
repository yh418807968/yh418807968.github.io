(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{216:function(t,a,s){"use strict";s.r(a);var _=s(28),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("在基于TCP协议的应用层协议需要发送消息时，会委托TCP/IP协议栈发送消息，而TCP协议是基于连接的，因此需要先建立连接再发送消息。本文主要讨论这一过程中的建立连接和断开连接的过程。")]),t._v(" "),s("p",[t._v("TCP的三次握手和四次挥手看过很多遍了，只是从宏观上记住了，但是具体这一过程干了些什么，并不是十分清楚，这次整体梳理下。")]),t._v(" "),s("h2",{attrs:{id:"创建套接字socket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建套接字socket"}},[t._v("#")]),t._v(" 创建套接字socket")]),t._v(" "),s("p",[t._v("什么是套接字？")]),t._v(" "),s("p",[t._v("解释起来比较复杂，我们做个比喻。客户端的应用程序A和与服务端应用程序a建立连接，就相当于在两者之间建立了一条管道，之后消息就在这条管道发送；可能还有很多其他应有程序在通信，会有很多其他管道，一个套接字就是识别对应管道的"),s("strong",[t._v("管道ID")]),t._v("，我们把这个ID称为"),s("strong",[t._v("描述符")]),t._v("。")]),t._v(" "),s("p",[t._v("创建套接字是通过操作系统的Socket库来实现，我们这里不用管，只用知道创建完之后会返回一个描述符，应用程序会将此描述符存放在内存中，之后需要发送这个消息就这个描述符来告诉TCP需要通过哪个管道入口发送消息。")]),t._v(" "),s("h2",{attrs:{id:"建立连接（三次握手）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建立连接（三次握手）"}},[t._v("#")]),t._v(" 建立连接（三次握手）")]),t._v(" "),s("p",[t._v("现在我还只是在客户端创建了套接字，但还没和服务端的套接字建立联系，也就是还只有管道入口，管道还没打通。")]),t._v(" "),s("h3",{attrs:{id:"_1、一次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、一次握手"}},[t._v("#")]),t._v(" 1、一次握手")]),t._v(" "),s("p",[t._v("建立连接需要知道目的地，所以需要带上"),s("strong",[t._v("服务端IP地址和端口号")]),t._v("。IP地址用来定位服务器，端口号用来定位服务器上的应用程序，通过服务端IP地址和端口号，就能准备定位到需要和哪个应用程序通信，然后对应到相应的服务端套接字，就可以确定管道出口了。剩下的就是把管道连起来了，这样确保之后的消息不会发错地方。")]),t._v(" "),s("blockquote",[s("p",[t._v("1、服务端应用程序在启动时，就创建好了套接字，等待连接。")])]),t._v(" "),s("blockquote",[s("p",[t._v("2、IP地址+端口、描述符都能唯一确定一个套接字。描述符供内部使用，是应用程序用来是被套接字的机制；IP地址+端口供外部使用，是客户端和服务端之间用来识别对方的套接字的机制。")])]),t._v(" "),s("p",[t._v("客户端创建一个TCP包，并随机给包分配一个初始序号i，将控制位SYN设置为1，表示这是一个发起连接的包。因此这一步就是：\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcuwzni0paj30qe0460sw.jpg",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"_2、二次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、二次握手"}},[t._v("#")]),t._v(" 2、二次握手")]),t._v(" "),s("p",[t._v("服务端收到消息后，需要告诉客户端自己收到消息了（ACK=1，ack=i+1），同时要告诉客户端自己可以连接(SYN=1);同时要返回自己的初始序列号seq=j。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlgy1gf00yaupr0j30tq06et9p.jpg",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"_3、三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、三次握手"}},[t._v("#")]),t._v(" 3、三次握手")]),t._v(" "),s("p",[t._v("客户端收到消息后，需要告诉服务端自己收到消息了（ACK=1，ack=j+1，seq=i+1）\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlgy1gf00z7d1hwj30ui08eabg.jpg",alt:""}})]),t._v(" "),s("p",[t._v("此时连接就建立完成了，之后发送消息，就无需再建立连接。应用程序只需要从内存中拿出描述符，并通过描述符找到对应的套接字，将需要发送的消息提交给套接字（入口），消息经由管道，最终服务端对应的套接字（出口）接收到，交给对应的应用程序。")]),t._v(" "),s("p",[s("strong",[t._v("序号")])]),t._v(" "),s("p",[t._v("这里简单说下序号seq的作用。\n每个包都有会带上一个seq，表示包中内容处于消息的第多少个字节，通过seq和包长度，接收端可以确定是否有遗漏或者错误。")]),t._v(" "),s("p",[t._v("比如seq=10，包长度为20，那接收端接收到消息后就会返回ack=31，发送方接收到这条消息了；另外，下一条消息的seq应该为31，接收端再收到消息，对比ack如果发信seq不为31，就知道消息接受错误。")]),t._v(" "),s("p",[t._v("TCP规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号(可以理解为，包的长度为1)，因此以上ack=i+1，即ack=seq+1。")]),t._v(" "),s("h2",{attrs:{id:"断开连接（四次挥手）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#断开连接（四次挥手）"}},[t._v("#")]),t._v(" 断开连接（四次挥手）")]),t._v(" "),s("p",[t._v("在设计上，协议栈允许管道两头的任一方主动断开连接，也就是客户端和服务端发送完消息后，都可以主动断开连接。这里以客户端主动发起断开为例。")]),t._v(" "),s("h3",{attrs:{id:"_1、一次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、一次挥手"}},[t._v("#")]),t._v(" 1、一次挥手")]),t._v(" "),s("p",[t._v("客户端想要断开连接，将表示断开的控制位FIN设置为1，seq=u（注意，"),s("strong",[t._v("此处的u为客户端上一个包的序号+1")]),t._v("）。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcuxrh3sesj30t00463yo.jpg",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"_2、二次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、二次挥手"}},[t._v("#")]),t._v(" 2、二次挥手")]),t._v(" "),s("p",[t._v("服务端收到消息后，需要告诉客户端自己收到消息了（ACK=1，ack=u+1），同时要返回自己的序列号seq=v（同样，此处服务端上一个包序号+1）。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcuxugcft8j30tc064t94.jpg",alt:""}})]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("此时没有在确认消息的同时返回FIN=1，也就是服务端没有告诉客户端它也需要断开。")]),t._v(" "),s("p",[t._v("当客户端发起断开时，服务端也许还有消息没发完，不能断开，所以客户端和服务端的断开是可以分开的，任何一方发起断开，只表示不再发送消息，但仍然可以接收消息，这也是为什么断开需要4次，而连接只需要3次的原因——因为连接必须是双方的，但断开可以是单向断开。")])]),t._v(" "),s("h3",{attrs:{id:"_3、三次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、三次挥手"}},[t._v("#")]),t._v(" 3、三次挥手")]),t._v(" "),s("p",[t._v("后两次挥手和前两次几乎一样，只是方向相反。发起方由客户端换为服务端。\n服务端也发完消息了，想要断开，将表示断开的控制位FIN设置为1，seq=w（中途可能又发了别的消息，w为上一个包的序号+1），并带上确认信息ACK=1，ack=u+1。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcuybbpgqmj30su07y3z5.jpg",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"_3、四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、四次挥手"}},[t._v("#")]),t._v(" 3、四次挥手")]),t._v(" "),s("p",[t._v("客户端收到服务端的消息后，需要告诉客户端自己收到消息了（ACK=1，ack=w+1），同时返回自己的序列号seq=u+1（客户端断开后，就没再发送消息，因此为u+1）。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcuybtf8i7j30se0bmaaz.jpg",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"为什么连接3次，断开4次"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么连接3次，断开4次"}},[t._v("#")]),t._v(" 为什么连接3次，断开4次")]),t._v(" "),s("p",[t._v("通过上面的解释，其实很清楚了。")]),t._v(" "),s("p",[s("strong",[t._v("连接的过程：")])]),t._v(" "),s("ul",[s("li",[t._v("客户端：hello，你可以听到吗（SYN=1）？")]),t._v(" "),s("li",[t._v("服务端：我可以听到（ACK=1），你可以听到吗（SYN=1）?")]),t._v(" "),s("li",[t._v("客户端：我也可以听到（ACK=1）")])]),t._v(" "),s("p",[t._v("于是接下来开始愉快的通信了。也就是每一方发起时，对方都需要确认，这样2放一共就需要4次，而接收方的发起和确认可以同时，于是最少需要3次。")]),t._v(" "),s("p",[s("strong",[t._v("断开的过程：")])]),t._v(" "),s("ul",[s("li",[t._v("客户端：hello，你要断开了，不再发送消息了（FIN=1）？")]),t._v(" "),s("li",[t._v("服务端：好的，我知道了，你断开吧（ACK=1）?")]),t._v(" "),s("li",[t._v("服务端：我也要断开了，不再发消息了（FIN=1）")]),t._v(" "),s("li",[t._v("客户端：好的，我知道了，你断开吧（ACK=1）")])]),t._v(" "),s("p",[t._v("因为一方断开后，另一方仍然可以发送消息，因此断开需要4次，也就是客户端发起->服务端确认，服务端发起->客户端确认。")]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("ul",[s("li",[t._v("《网路是怎样连接的》 [日] 户根勤/著 周自恒/译")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/ns_code/article/details/29382883",target:"_blank",rel:"noopener noreferrer"}},[t._v("【网络协议】TCP连接的建立和释放"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=v.exports}}]);