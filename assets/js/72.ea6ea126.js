(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{288:function(a,t,s){"use strict";s.r(t);var r=s(28),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"模块化的好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化的好处"}},[a._v("#")]),a._v(" 模块化的好处")]),a._v(" "),s("ul",[s("li",[a._v("避免命名冲突(减少命名空间污染)")]),a._v(" "),s("li",[a._v("更好的分离, 按需加载")]),a._v(" "),s("li",[a._v("更高复用性")]),a._v(" "),s("li",[a._v("高可维护性")])]),a._v(" "),s("h2",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[a._v("#")]),a._v(" 函数")]),a._v(" "),s("p",[a._v("将不同功能的代码实现封装到不同的函数中。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。\n【缺点】")]),a._v(" "),s("ul",[s("li",[a._v("容易发生命名冲突（数据命名冲突）")]),a._v(" "),s("li",[a._v("数据的不安全性（函数内部的数据可以在外部被修改，比如返回的函数能修改闭包中的函数；函数内部数据也可能污染全局作用域里的数据）")])]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("func")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("h2",{attrs:{id:"立即执行函数（相当于块级作用域）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数（相当于块级作用域）"}},[a._v("#")]),a._v(" 立即执行函数（相当于块级作用域）")]),a._v(" "),s("p",[a._v("立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。**通过函数作用域解决了命名冲突、污染全局作用域的问题 **")]),a._v(" "),s("h2",{attrs:{id:"amd-cmd——浏览器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd-cmd——浏览器"}},[a._v("#")]),a._v(" AMD/CMD——浏览器")]),a._v(" "),s("p",[a._v("都是异步加载，适用于浏览器")]),a._v(" "),s("h2",{attrs:{id:"commonjs-——-服务器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-——-服务器"}},[a._v("#")]),a._v(" CommonJS —— 服务器")]),a._v(" "),s("ul",[s("li",[a._v("同步，只有加载完成，才能执行后面的操作")]),a._v(" "),s("li",[a._v("适用于服务端(Node.js)：因为服务端的模块一般就存在与本地磁盘，加载较快；而浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式")])]),a._v(" "),s("h2",{attrs:{id:"es6模块——浏览器与服务器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6模块——浏览器与服务器"}},[a._v("#")]),a._v(" ES6模块——浏览器与服务器")]),a._v(" "),s("h4",{attrs:{id:"浏览器加载es6模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器加载es6模块"}},[a._v("#")]),a._v(" 浏览器加载Es6模块")]),a._v(" "),s("p",[a._v("使用"),s("code",[a._v("<script>")]),a._v("标签，加入"),s("code",[a._v('type="module"')]),a._v("属性")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("script type"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"module"')]),a._v(" src"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"./foo.js"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),s("h4",{attrs:{id:"服务器加载es6模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务器加载es6模块"}},[a._v("#")]),a._v(" 服务器加载Es6模块")]),a._v(" "),s("p",[a._v("此时就需要与CommonJs对比了")]),a._v(" "),s("h2",{attrs:{id:"差异——commonjs与es6模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#差异——commonjs与es6模块"}},[a._v("#")]),a._v(" 差异——CommonJS与Es6模块")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。")])]),a._v(" "),s("li",[s("p",[a._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")])])]),a._v(" "),s("p",[a._v("解释下："),s("strong",[a._v("ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块")]),a._v("。")]),a._v(" "),s("h2",{attrs:{id:"babel"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[a._v("#")]),a._v(" Babel")]),a._v(" "),s("p",[a._v("鉴于浏览器支持度的问题，如果要使用 ES6 的语法，一般都会借助 Babel。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// ES6\nimport {firstName, lastName, year} from './profile';\n// Babel 编译后\n'use strict';\nvar _profile = require('./profile');\n")])])]),s("p",[a._v("你会发现 Babel 只是把 ES6 模块语法转为 CommonJS 模块语法，然而浏览器是不支持这种模块语法的，所以直接跑在浏览器会报错的，如果想要在浏览器中运行，还是需要使用打包工具将代码打包")]),a._v(" "),s("h2",{attrs:{id:"webpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" webpack")]),a._v(" "),s("p",[a._v("浏览器环境中并没有 module、 exports、 require 等环境变量，因此不支持CommonJs，因此在Babel将转换为CommonJs语法后，需要webpack对其进行打包，而**webpack 打包后的文件之所以在浏览器中能运行，就是模拟了这些环境变量的行为。")]),a._v(" "),s("p",[s("strong",[a._v("将 ES6、CommonJS 等模块化通过自己内部的机制统一成 webpack 的模块化")]),a._v("\n（还不是很懂）\nhttps://blog.lbinin.com/frontEnd/JavaScript/Module-Import.html")])])}),[],!1,null,null,null);t.default=e.exports}}]);