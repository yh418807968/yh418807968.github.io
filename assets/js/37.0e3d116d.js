(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{256:function(t,a,_){"use strict";_.r(a);var s=_(28),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("适合求解最优解问题")]),t._v(" "),_("h3",{attrs:{id:"_3个特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3个特点"}},[t._v("#")]),t._v(" 3个特点")]),t._v(" "),_("ul",[_("li",[t._v("最优子结构")])]),t._v(" "),_("p",[t._v("最优解包含子问题的最优解(其实就是递归的条件，大问题可以拆成小问题，此小问题除了数据规模更小，思路是一样的)")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("无后效性\n在推到后面阶段的状态时，只用关心前一步的状态，不用管这个状态时如何一步步推到过来的。也就是之前的步骤对后续步骤没有后效性")])]),t._v(" "),_("li",[_("p",[t._v("重复子问题\n不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。（这样也正体现了动态规划相对暴力穷举的优势）")])])]),t._v(" "),_("h3",{attrs:{id:"_2种方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2种方法"}},[t._v("#")]),t._v(" 2种方法")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("状态表")])]),t._v(" "),_("li",[_("p",[t._v("状态转移方程")])])]),t._v(" "),_("h3",{attrs:{id:"备注"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#备注"}},[t._v("#")]),t._v(" 备注")]),t._v(" "),_("p",[t._v("递归的至顶向下，动态规划是至底向上n^2")])])}),[],!1,null,null,null);a.default=r.exports}}]);