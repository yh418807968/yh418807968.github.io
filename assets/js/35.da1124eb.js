(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{258:function(t,a,s){"use strict";s.r(a);var r=s(28),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#思想"}},[t._v("#")]),t._v(" 思想")]),t._v(" "),s("p",[t._v("二分查找，针对的是一个"),s("strong",[t._v("有序的数据")]),t._v("集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。")]),t._v(" "),s("p",[t._v("一般会用3个指针来实现，low和high表示当前要查找的数据范围，mid表示中间位置")]),t._v(" "),s("h3",{attrs:{id:"容易出错的3个地方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容易出错的3个地方"}},[t._v("#")]),t._v(" 容易出错的3个地方")]),t._v(" "),s("h4",{attrs:{id:"_1、循环退出条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、循环退出条件"}},[t._v("#")]),t._v(" 1、循环退出条件")]),t._v(" "),s("h4",{attrs:{id:"_2、mid的取值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、mid的取值"}},[t._v("#")]),t._v(" 2、mid的取值")]),t._v(" "),s("h4",{attrs:{id:"_3、low和high的更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、low和high的更新"}},[t._v("#")]),t._v(" 3、low和high的更新")]),t._v(" "),s("h3",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("必须为顺序表结构，其实就是数组\n不能为其他数据结构，比如链表。因为二分查找的主要思想要依赖随机访问，数组随机访问的复杂度为O(1)，而链表为O(n)，如果用链表则时间复杂度为很高")])]),t._v(" "),s("li",[s("p",[t._v("必须为有序数据\n如果数据无序，需要先排序")])]),t._v(" "),s("li",[s("p",[t._v("数据量太小不适合二分查找\n数据量太小直接用顺序遍历就足够，没有必要用二分查找")])]),t._v(" "),s("li",[s("p",[t._v("数据量太大不适合二分查找\n因为二分查找需要采用数组存储，而数组采用连续空间，因此数据量太大的话就无法申请到一个连续空间")])])])])}),[],!1,null,null,null);a.default=_.exports}}]);