(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{281:function(v,_,a){"use strict";a.r(_);var t=a(28),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("p",[v._v("变量会被保存在栈或者堆中，栈的垃圾很好回收，只要是栈顶指针以上的都是不可访问对象，后续入栈时直接覆盖即可。因此此处垃圾回收特指回收堆中的数据。")]),v._v(" "),a("h2",{attrs:{id:"垃圾回收整体流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收整体流程"}},[v._v("#")]),v._v(" 垃圾回收整体流程")]),v._v(" "),a("h4",{attrs:{id:"_1、标记垃圾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、标记垃圾"}},[v._v("#")]),v._v(" 1、标记垃圾")]),v._v(" "),a("p",[v._v("通过"),a("strong",[v._v("可访问算法")]),v._v("来标记空间中的活动对象和非活动对象。将GC ROOT作为初始活动对象，从GC ROOT出发，遍历GC ROOT中的所有对象，哪些不可访问到的对象就会被标记为非活动对象，需要被回收。")]),v._v(" "),a("p",[v._v("在浏览器环境中，GC ROOT有很多，比如：")]),v._v(" "),a("ul",[a("li",[v._v("全局window对象")]),v._v(" "),a("li",[v._v("文档DOM树")]),v._v(" "),a("li",[v._v("存放在栈上的变量")])]),v._v(" "),a("h4",{attrs:{id:"_2、回收垃圾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、回收垃圾"}},[v._v("#")]),v._v(" 2、回收垃圾")]),v._v(" "),a("p",[v._v("标记完成后，统一清理内存中所有非活动对象。")]),v._v(" "),a("h4",{attrs:{id:"_3、内存整理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、内存整理"}},[v._v("#")]),v._v(" 3、内存整理")]),v._v(" "),a("p",[v._v("频繁回收对象后，内存中可能会存在大量不连续空间(内存碎片)，之后如果要分配较大的连续内存时，可能会出现内存不足的情况，因此需要进行内存整理。")]),v._v(" "),a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),a("p",[v._v("V8采用两个垃圾回收器，主垃圾回收器和副垃圾回收器。之所以使用了两个垃圾回收器，主要是受到了代际假说（The Generational Hypothesis）的影响")]),v._v(" "),a("p",[a("strong",[v._v("代际假说")]),v._v("是垃圾回收领域中一个重要的术语，它有以下两个特点：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；")])]),v._v(" "),a("li",[a("p",[v._v("第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。")])])]),v._v(" "),a("p",[v._v("其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。")]),v._v(" "),a("p",[v._v("基于代际假说，如果我们只使用一个垃圾回收器，在优化大多数新对象的同时，就很难优化到那些老对象，因此你需要权衡各种场景，根据对象生存周期的不同，而使用不同的算法，以便达到最好的效果。")]),v._v(" "),a("p",[v._v("所以，在V8中，会把堆分为"),a("strong",[v._v("新生代")]),v._v("和"),a("strong",[v._v("老生代")]),v._v("两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。新生代通常只有1~8M的容量，老生代支持的容量就大很多了。因此大部分小的对象会被分配到新生代。")]),v._v(" "),a("p",[v._v("对于这两块区域，V8使用不同的垃圾回收器：")]),v._v(" "),a("ul",[a("li",[v._v("副垃圾回收器 -Minor GC (Scavenger)，主要负责新生代的垃圾回收。")]),v._v(" "),a("li",[v._v("主垃圾回收器 -Major GC，主要负责老生代的垃圾回收。")])]),v._v(" "),a("h3",{attrs:{id:"副垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[v._v("#")]),v._v(" 副垃圾回收器")]),v._v(" "),a("p",[v._v("副垃圾回收器主要负责新生代的垃圾回收，采用Scavenge 算法：将新生代空间对半分为2个区域——对象区域和空闲区域。\n"),a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlgy1geqj35esa2j31hc0u0jvf.jpg",alt:""}})]),v._v(" "),a("p",[v._v("新加入的对象都会被存入对象区，当对象区存满了之后，就会进入垃圾清理阶段。从GC ROOT遍历，遇到存活对象就直接复制到空闲区域，同时把这些对象有序排列，也就是说完成了内存整理的操作。\n"),a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlgy1geqj7r96y3j31hc0u0q5u.jpg",alt:""}}),v._v("\n复制完成后，将空闲区和对象区对调，此时对象区中就是活动对象了，而空闲区就都是垃圾数据直接全部清理掉即可。这种操作就可以保证两块区域无限重复使用下去。")]),v._v(" "),a("p",[v._v("由于副垃圾回收器每次执行清理时，都要将活动对象赋值到空闲区，如果新生区空间设置的太呆，那么每次清理就会很耗时，因此为了保证效率，新生区会被设置的比较小。")]),v._v(" "),a("h3",{attrs:{id:"主垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[v._v("#")]),v._v(" 主垃圾回收器")]),v._v(" "),a("p",[v._v("主垃圾回收器主要负责老生代中的垃圾回收。老生代的数据主要来源于2点：")]),v._v(" "),a("ul",[a("li",[v._v("存货时间比较长的对象 —— 新生区通过对象晋升策略被移动至老生代，即经过2次垃圾回收依然存活的对象会被移动到老生代")]),v._v(" "),a("li",[v._v("占用空间较大的对象")])]),v._v(" "),a("p",[v._v("主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法（如果继续采用标记清除的方法，复制大对象的执行效率不高），标记清除直接将标记为非活动对象的数据清理掉。")]),v._v(" "),a("p",[v._v("但这样会产生大量的内存碎片，因此又引入了另一种算法——标记 - 整理（Mark-Compact）。标记整理不是直接清理非活动对象，而是让所有存货")]),v._v(" "),a("p",[v._v("疑问：")]),v._v(" "),a("ul",[a("li",[v._v("引用计数和标记清除的区别？")]),v._v(" "),a("li",[v._v("复制算法和标记整理的区别\n（复制算法中存活对象较少，且直接在遍历的时候复制就可以，效率较高）")])]),v._v(" "),a("h2",{attrs:{id:"优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[v._v("#")]),v._v(" 优化")]),v._v(" "),a("p",[v._v("垃圾回收是运行在主线程上的，所以一旦进行垃圾回收，就会导致主线程进入“全停顿”状态，就可能会造成页面的卡顿。")]),v._v(" "),a("p",[v._v("为了解决此问题，V8中增加了并行、并发和增量等垃圾回收机制，主要从以下2方面解决垃圾回收效率问题：")]),v._v(" "),a("ul",[a("li",[v._v("将垃圾回收任务分为多个小任务")]),v._v(" "),a("li",[v._v("将一些任务转到后台线程中\n"),a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlgy1geql5lz3kpj31rg0jptaz.jpg",alt:""}})])]),v._v(" "),a("h3",{attrs:{id:"并行回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并行回收"}},[v._v("#")]),v._v(" 并行回收")]),v._v(" "),a("p",[v._v("并行回收是指垃圾回收器在主线程上执行的过程中，还会开启多个协助线程，同时执行同样的回收工作。")]),v._v(" "),a("p",[v._v("并行回收只是通过多线程缩短垃圾回收的时间，能较好的优化副垃圾回收器；但全停顿仍然存在，对老生代中的对象，仍然会花费较多时间，因此V8又引入了增量回收。")]),v._v(" "),a("h3",{attrs:{id:"增量回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量回收"}},[v._v("#")]),v._v(" 增量回收")]),v._v(" "),a("h3",{attrs:{id:"并发回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发回收"}},[v._v("#")]),v._v(" 并发回收")])])}),[],!1,null,null,null);_.default=r.exports}}]);